<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<style type="text/css" media="screen">
	body{
		border-radius: 10px;
	}	
	</style>
</head>
<body>
	<h1>hello test</h1>
	<div id="ev">ok<div>
	<!-- <a  id=pic1  style="cursor:pointer">点击下载</a>  -->
	<a href="##" download="https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo/logo_white_fe6da1ec.png">下载图片</a>
</body>
<!-- <script type="text/javascript" src="http://w.abcs.com/ssdd/a.js"></script> -->
<script>
	// 把公用的方法与属性抽离出来 生成成一个构造函数，  把抽离出来的方法属性 通过 prototype 绑定在构造函数上，
	// 如果要继承构造函数的属性与方法 需要通过实例(new)，实例的方法就有了构造函数的方法与属性，实例的原型对象（__proto__）与构造函数的原型(prototype)对象相同
	// 构造函数.prototype.constructor指向 构造函数
	// 实例的__proto__.constructor 指向  构造函数

// 	function Car(color,price){
// 			this.color=color;
// 			this.price=price;
// 	}
// Car.prototype.sali=function(){
// 			console.log( this.color +'的车卖了'+this.price+"万元！！")
// }
// var bmw=new Car('蓝色','10');
// bmw.sali()
// console.dir(bmw.__proto__.constructor == Car)
// console.dir(Car.prototype.constructor == Car )
// console.dir(Car.prototype  == bmw.__proto__ )



















// function swap(items, firstIndex, secondIndex){
//     var temp = items[firstIndex];
//     items[firstIndex] = items[secondIndex];
//     items[secondIndex] = temp;
// }
 
// function partition(items, left, right) {
//     var pivot   = items[Math.floor((right + left) / 2)],
//         i       = left,
//         j       = right;
//     while (i <= j) {
//         while (items[i] < pivot) {
//             i++;
//         }
//         while (items[j] > pivot) {
//             j--;
//         }
//         if (i <= j) {
//             swap(items, i, j);
//             i++;
//             j--;
//         }
//     }
//     return i;
// }

// function quickSort(arr, left, right) {
//     var len = arr.length,
//         partitionIndex,
//         left = typeof left != 'number' ? 0 : left,
//         right = typeof right != 'number' ? len - 1 : right;

//     if (left < right) {
//         partitionIndex = partition(arr, left, right);
//         quickSort(arr, left, partitionIndex-1);
//         quickSort(arr, partitionIndex+1, right);
//     }

//     return arr;
// }



// var items = [4, 2, 6, 5, 3, 9];
// var result = quickSort(items);
// console.log(result)

// function swap(items, firstIndex, secondIndex){
//     var temp = items[firstIndex];
//     items[firstIndex] = items[secondIndex];
//     items[secondIndex] = temp;
// }

// function partition(items, left, right) {
//     var pivot = items[Math.floor((right + left) / 2)],
//         i = left,
//         j = right;
//     while (i <= j) {
//         while (items[i] < pivot) {
//             i++;
//         }
//         while (items[j] > pivot) {
//             j--;
//         }
//         if (i <= j) {
//             swap(items, i, j);
//             i++;
//             j--;
//         }
//     }
//     return i;
// }

// function quickSort(items, left, right) {
//     var index;
//     if (items.length > 1) {
//         index = partition(items, left, right);
//         if (left < index - 1) {
//             quickSort(items, left, index - 1);
//         }
//         if (index < right) {
//             quickSort(items, index, right);
//         }
//     }
//     return items;
// }

// var items = [3,8,7,2,9,4,10]
// var result = quickSort(items, 0, items.length - 1);
// console.log(result)



// function selectionSort(arr) {
//     var len = arr.length;
//     var minIndex, temp;
//     for (var i = 0; i < len - 1; i++) {
//         minIndex = i;
//         for (var j = i + 1; j < len; j++) {
//             if (arr[j] < arr[minIndex]) {     // 寻找最小的数
//                 minIndex = j;                 // 将最小数的索引保存
//             }
//         }
//         temp = arr[i];
//         arr[i] = arr[minIndex];
//         arr[minIndex] = temp;
//     }
//     return arr;
// }


// function insertionSort(arr) {
//     var len = arr.length;
//     var preIndex, current;
//     for (var i = 1; i < len; i++) {
//         preIndex = i - 1;
//         current = arr[i];
//         while(preIndex >= 0 && arr[preIndex] > current) {
//             arr[preIndex+1] = arr[preIndex];
//             preIndex--;
//         }
//         arr[preIndex+1] = current;
//     }
//     return arr;
// }

// var items = [3,8,7,2,9,4,10]
// var result = selectionSort(items);
// console.log(result)




















// function quickSort(array){
//     function sort(prev, numsize){
//         var nonius = prev;
//         var j = numsize -1;
//         var flag = array[prev];
//         if ((numsize - prev) > 1) {
//             while(nonius < j){
//                 for(; nonius < j; j--){
//                     if (array[j] < flag) {
//                         array[nonius++] = array[j];　//a[i] = a[j]; i += 1;
//                         break;
//                     };
//                 }
//                 for( ; nonius < j; nonius++){
//                     if (array[nonius] > flag){
//                         array[j--] = array[nonius];
//                         break;
//                     }
//                 }
//             }
//             array[nonius] = flag;
//             sort(0, nonius);
//             sort(nonius + 1, numsize);
//         }
//     }
//     sort(0, array.length);
//     return array;
// }
// console.log(quickSort([23,11,89,45,67,76,56,99]))












	


	// document.getElementById('pic1').onclick=function(){
	// 	console.log('ok')
	// 	download('https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo/logo_white_fe6da1ec.png')
	// }

	// function download(src) {
	// 	console.log('ok')
	//     var $a = document.createElement('a');
	//     $a.setAttribute("href", src);
	//     $a.setAttribute("download", "");
	//     var evObj = document.createEvent('MouseEvents');
	//     evObj.initMouseEvent( 'click', true, true, window, 0, 0, 0, 0, 0, false, false, true, false, 0, null);
	//     $a.dispatchEvent(evObj);
	// };



	// function savepic() { 
	// 　　if (document.all.a1 == null) { 
	// 　　　　objIframe = document.createElement("IFRAME"); 
	// 　　　　document.body.insertBefore(objIframe); 
	// 　　　　objIframe.outerHTML = "<iframe name=a1 style='width:400px;hieght:300px' src='http://ico.58pic.com/iconset01/Death-note-icons/gif/86559.gif '></iframe>"; 
	// 　　　　re = setTimeout("savepic()", 1) 
	// 　　} else { 
	// 　　　　clearTimeout(re) 
	// 　　　　pic = window.open(imageName.href, "a1") 
	// 　　　　pic.document.execCommand("SaveAs") 
	// 　　　　document.all.a1.removeNode(true) 
	// 　　} 
	// } 



	// var obj={
	// 	foo:'bar',
	// 	fun:function(){
	// 		var self=this;
	// 		console.log('output '+this.foo)	
	// 		console.log('output' +self.foo);
	// 		(function(){
	// 			console.log('inner '+this.foo);	
	// 			console.log('inner '+self.foo);
	// 		}())
	// 	}
	// }
	// obj.fun()


	// var res=0;
	// for(var i=1, k=1; i<5, k<10;i++,k++){
	// 	console.log(i)
	// 	console.log(k)
	// 	res=i+ks
	// }
	// console.log(res)


	// window.addEventListener("error", function(evt){
	// 	console.log('hello error')
	// })

	// (window.onerror = function(msg, url, line){ 
	// 		console.log(msg)
	// 		console.log(url)
	// 		console.log(line)
	//  })()

	// window.onerror=function(){
	// 	console.error('error')
	// }

	// var a =25;
	// (function(){
	// 	console.log(a)
	// 	var a=30;
	// })




	// for(var i=0; i<5; i++){
	// 	setTiemout(function(){
	// 		console.log(i)
	// 	},1000)
	// }

	// var a = {m:'12'}
	// var b = {m:'12'}
	// var arr=[];
	// var obj={}
	// var nu=null
	// var und=undefined
	// var no=
	// console.log(a==b)
	// console.log(Boolean(a))
	// console.log(Boolean(arr))
	// console.log(Boolean(obj))
	// console.log(Boolean( nu))
	// console.log(Boolean( und))
	// console.log(Boolean( no))


	// new set()

	// var a=[1,2,3,4,5];
	// var b=a.map(function(i,v){
	// 	return i+1
	// });
	// console.log(b)
	// console.log(a)

//concat(): 合并数组
//copyWithin() es6 数组实例新增 数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。
//entries()  :方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对
//every():返回一个boolean，判断每个元素是否符合func条件
//fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素
//filter(): 返回一个符合func条件的元素数组
//find() :函数用来查找目标元素，找到就返回该元素，找不到返回undefined
//findIndex() 方法返回数组中满足提供的测试函数的第一个元素的索引
//forEach():没有返回值，只是针对每个元素调用func
//includes(): 函数判断是否包含某一元素，除了不能定位外，解决了indexOf的上述的两个问题。它直接返回true或者false表示是否包含元素，对NaN一样能有有效。
//indexOf() 方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1
// isArray
//join(): 拼接数组元素
//keys() :方法返回一个新的Array迭代器，它包含数组中每个索引的键
//lastIndexOf() :lastIndexOf() 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。
//map() :返回一个新的Array，每个元素为调用func的结果
//pop() :尾部删除pop
//push(): 尾部添加
//reduce():返回一个计算后的值
//reduceRight():没有返回值，只是针对每个元素调用func
//reverse():颠倒数组元素
//shift():头部删除
//slice()  方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象。且原始数组不会被修改
//some():返回一个boolean，判断是否有元素是否符合func条件
//splice():删除或插入元素
//toLocaleString():返回一个字符串表示数组中的元素。数组中的元素将使用各自的 toLocaleString 方法转成字符串，这些字符串将使用一个特定语言环境的字符串（例如一个逗号 ","）隔开。
//toString() ： 方法返回指定的布尔对象的字符串形式。
//unshift():头部添加
 //sort(): 排序

// const nums = [2 ,4 , 6, ...odd];
// let arr = [1,2,4,5,2,5,6,12]
// console.log(Array.from(new Map(...arr)))


	//数组深拷贝
	// var array = [1, 2, 3, 4];
	// var testArray =  Array.from(array);
	// testArray.push(5)
	//方法二
	// var array = [1, 2, 3, 4];
	// var tasarr= JSON.parse(JSON.stringify(array))
	// tasarr.push(5)
	// console.log(tasarr)
    // 数组去重
	// var tt =[...new Set([1,2,3,4,1,3,4,6])]
	// var set1 = Array.from(new Set([1,1,2,2,33,'33',44,'44']))
	//方法二
	// var arr= [12,24,56,78,32,12,24];
	// var obj={};
	// var newArr=[];
	// for(var i=0;i<arr.length;i++){
	// 	if(!obj[arr[i]]){
	// 		newArr.push(arr[i]);
	// 		obj[arr[i]]=1;
	// 	}
	// }
	// console.log(newArr)


	
	// cookie 设置过期时间

	let set = new Set(['red', 'green', 'no']);
	console.log(set)
	console.log(typeof set)
console.log(Array.isArray(set))
	var setArr=Array.from(set)  //输出[1,2,3,4]
	console.log(setArr)
	console.log(typeof setArr)
	console.log(Array.isArray( setArr))


	//  var a=[];
	//  var b={};
	//  console.log(Array.isArray(a));//true
 // 	 console.log(Array.isArray(b))//false
	//concat 数组合并
// 	let arr1=[1,2,3]; 
// let arr2=[4,5,6]; 
// Array.prototype.push.apply(arr1,arr2); //将arr2合并到了arr1中


	// let mp = new Map(['red', 'green', 'no']);
	// console.log(mp)
	// console.log(typeof mp)

	// window.devicePixelRatio //dpr

	 // 200 OK (from cache)  是浏览器没有跟服务器确认，直接用了浏览器缓存；而 304 Not Modified 是浏览器和服务器多确认了一次缓存有效性

	 // hash


	 // axios.interceptors.request.use  请求劫持
	 // ajax同步请求 async false




	// var arr = [1,[2,3],[4,5,[6,7]]];
	// console.log(arr+'')
	// var newArr= (arr + ' ').split(',')
	// console.log(newArr)

	
	// event.preventDefault()//，是用来阻止点击a默认跳转
	// event.stopPropagation()// 该方法将停止事件的传播，阻止它被分派到其他 Document 节点
	// event.stopImmediatePropagation() //函数用于阻止剩余的事件处理函数的执行，并防止当前事件在DOM树上冒泡。
	// event.target //返回的是点击的元素节点
	// event.currentTarget //事件属性返回其监听器触发事件的节点，即当前处理该事件的元素、文档或窗口。

	// 自定义事件
	// var ev = document.getElementById('ev');
	// var  eve =new Event('custome');
	// window.addEventListener('custome',function(){
	// 	console.log('custome');
	// });
	// setTimeout(function(){
	// 	window.dispatchEvent(eve);
	// },1000)

	//跨域
	// jsonp   Hash cors  webSocker  postMessage

	// var quickSort = function(arr) {
	//     if (arr.length <= 1) { return arr; }
	//     var pivotIndex = Math.floor(arr.length / 2);   //基准位置（理论上可任意选取）
	//     var pivot = arr.splice(pivotIndex, 1)[0];  //基准数
	//     var left = [];
	//     var right = [];
	//     for (var i = 0; i < arr.length; i++){
	//         if (arr[i] < pivot) {
	//             left.push(arr[i]);
	//         } else {
	//             right.push(arr[i]);
	//         }
	//     }
	//     return quickSort(left).concat([pivot], quickSort(right));  //链接左数组、基准数构成的数组、右数组
	// };

	// var quick=quickSort([29,5,40,21,32,12,8,99])
	// console.log(quick)



// es7
//async/await  异步 
// /Users/lihaibo/Library/Application Support/Sublime Text 3/Packages/JSLint
// Array.prototype.includes()。  是查找一个值在不在数组里，若在，则返回true，反之返回fals
//3 ** 2     //求幂运算符（**）



//es8
//async function foo() {}
//Object.entries()   //如果一个对象是具有键值对的数据结构，则每一个键值对都将会编译成一个具有两个元素的数组，这些数组最终会放到一个数组中，返回一个二维数组
// Object.values()只返回自己的键值对中属性的值
//Object.getOwnPropertyDescriptors()
//padStart()。//'x'.padStart(4, 'ab') abax
//padEnd()。//'x'.padEnd(4, 'ab')   xaba


//es6 
// let const.   字符串模版, 箭头函数, 结构赋值, promise, 默认参数。import(导入) 和 export(导出):


// Babel默认只转换新的JavaScript句法（syntax），而不转换新的API，比如Iterator、Generator、Set、
// Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。
// babel-polyfill主要包含了core-js和regenerator两部分

// babel-polyfill：提供了如ES5、ES6、ES7等规范中 中新定义的各种对象、方法的模拟实现。
// regenerator：提供generator支持，如果应用代码中用到generator、async函数的话用到。


// ## react16
// > React 16 采用了称为“Fiber”的全新的内部架构。官方对 Fiber 的一句话解释是“React Fiber是对核心算法的一次重新实现
// > render 方法能够返回数组了  //但是要使用 key
// > ReactDOM.createPortal //新增了一个顶级 API
// > setState传入null时不会再触发更新
// > componentDidCatch(error, info) 的生命周期函数，你可以定义组件的错误处理函数，这样组件在遇到运行时错误时会像增加了 try...catch 一样，不会将错误直接抛出了，错误被局部组件 catch 住，保证了整个应用的可用性。
// > react 是5.3kb（gzip：2.2kb），之前是20.7kb（gzip：6.9kb）
// > react-dom 是103.7kb（gzip：32.6kb），之前是141kb（gzip：42.9kb）
// > react + react-dom 是109kb（gzip：34.8kb），之前是161.7kb（gzip：49.8kb）


// ## react 16.3
// > React.createContext()，这样就创建了两个组件：
// > 要被废弃的方法：
// > componentWillMount--使用componentDidMount代替
// > componentWillUpdate--使用componentDidUpdate代替
// > componentWillReceiveProps--使用一个新的方法：static getDerivedStateFromProps来代替。




// webpack4
// 另一个大的改变是webpack需要设置mode属性，可以是 development 或 production。
// webpack4受Parcel打包工具启发，尽可能的让开发者运行项目的成本变低。为了做到0配置，webpack4不再强制需要 webpack.config.js 作为打包的入口配置文件了，它默认的入口为'./src/'和默认出口'./dist'，
// webpack4删除了CommonsChunkPlugin插件，它使用内置API optimization.splitChunks 和 ** optimization.runtimeChunk **，这意味着webpack会默认为你生成共享的代码块。其它插件变化如下:
// NoEmitOnErrorsPlugin 废弃，使用optimization.noEmitOnErrors替代，在生产环境中默认开启该插件。
// ModuleConcatenationPlugin 废弃，使用optimization.concatenateModules替代，在生产环境默认开启该插件。
// NamedModulesPlugin 废弃，使用optimization.namedModules替代，在生产环境默认开启。
// uglifyjs-webpack-plugin升级到了v1.0版本, 默认开启缓存和并行功能。


// Webpack5展望
// 已经有不少关于webpack5的计划正在进行中了，包括以下：

// 对WebAssembly的支持更加稳定
// 支持开发者自定义模块类型
// 去除ExtractTextWebpackPlugig插件，支持开箱即用的CSS模块类型
// 支持Html模块类型
// 持久化缓存

//小程序



//你的项目
//遇到的难题


// window.onerror
// try catch



// object.onerror

// preformance.getEntries()
// error捕获
	
	
	
//正则匹配 手机号码
// 	"12345678901".replace(/(^\d{3}|\d{4}\B)/g,"$1-");
//      '99893'.replace(/\B(?=(?:\d{3})+$)/g, ',')  // '99,893'

//目前的学习任务
// node+koa2+pm2
//rn,nw跨平台开发
// three.js cocos2d 

//redux
//


// video 抖动
// flex 定位失效
// 1像素问题
// 阻止旋转屏幕时自动调整字体大小
// html, body, form, fieldset, p, div, h1, h2, h3, h4, h5, h6 {-webkit-text-size-adjust:none;}
// 动端修改难看的点击的高亮效果，iOS和安卓下都有效：
// {-webkit-tap-highlight-color:rgba(0,0,0,0);}
// iphone及ipad下输入框默认内阴影

// Element{
//   -webkit-appearance:none;
// }

// 13、ios和android下触摸元素时出现半透明灰色遮罩

// Element {
//   -webkit-tap-highlight-color:rgba(255,255,255,0)
// }


// typeof 实现原理
// typeof 一般被用于判断一个变量的类型，我们可以利用 typeof 来判断number, string, object, boolean, function, undefined,symbol 这七种类型，这种判断能帮助我们搞定一些问题，比如在判断不是 object 类型的数据的时候，typeof能比较清楚的告诉我们具体是哪一类的类型。但是，很遗憾的一点是，typeof 在判断一个 object的数据的时候只能告诉我们这个数据是 object, 而不能细致的具体到是哪一种 object, 

// null：所有机器码均为0 typeof null  是object

// instanceof 操作符的实现原理
// 原型的链式查找
// 03.__proto__.constructor==m
// instanceof 主要的实现原理就是只要右边变量的 prototype 在左边变量的原型链上即可。因此，instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype，如果查找失败，则会返回 false，告诉我们左边变量并非是右边变量的实例

// Object.prototype.toString.call(1) // "[object Number]"
// Object.prototype.toString.call('hi') // "[object String]"
// Object.prototype.toString.call({a:'hi'}) // "[object Object]"
// Object.prototype.toString.call([1,'a']) // "[object Array]"
// Object.prototype.toString.call(true) // "[object Boolean]"
// Object.prototype.toString.call(() => {}) // "[object Function]"
// Object.prototype.toString.call(null) // "[object Null]"
// Object.prototype.toString.call(undefined) // "[object Undefined]"
// Object.prototype.toString.call(Symbol(1)) // "[object Symbol]"


// var obj={}
// // obj.prototype.say=function(){
// // 	console.log('jell')
// // }
// obj.x=1;
// for(var i in obj){
// 	console.log(i)
// }
// console.log(obj.toString)
// console.log(obj.__proto__)



//函数重载
// 重载就是一组具有相同名字、不同参数列表的函数（方法）
//使用 arguments.length 可以实现重载

// setTimeout共有4个参数。最后那两个参数，将在1000毫秒之后回调函数执行时，作为回调函数的参数。
//最小间隔不是0 而是4毫秒
// Promise

// 三种状态:
// pending：进行中
// fulfilled :已经成功 reslove
// rejected 已经失败 reject

// promise 有一个 then 方法， then 方法可以接受 3 个函数作为参数。前两个函数对应 promise 的两种状态 fulfilled 和 rejected 的回调函数
// ,第三个函数用于处理进度信息（对进度回调的支持是可选的）。
// 原理
// var promise = new Promise(function (resolve, reject) {
//   if (/* 异步操作成功 */){
//     resolve(value);
//   } else { /* 异步操作失败 */
//     reject(new Error());
//   }
// });



// 错误分类

// 1 即时运行错误
// 捕获错误
// try ...catch
// window.onerror()

// 2资源加载失败

// 捕获错误
// object.onerror()(图片 script)
// performance.getEnries() 返回数组 


// 资源加载失败不能用冒泡得到错误,可以用捕获处理可以到的错误监听

// 捕获错误
// try ...catch
// window.onerror()


// 上报
//  (new Image()).src='http://www.baidu.com?sa=we';
//  navigator.sendBeacon("a.php");  //埋点




// 高效开发方式
// 开发环境
// 书写规范
// 开发规范 
// 内需
// 知识体系分享
// 组件库建立
// 版本依赖



架构
模块
版本升级
文件划分
持续可扩







</script>
</html> 
